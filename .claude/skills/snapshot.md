---
name: snapshot
autoContext: true
description: Creates Snapshot Tests for SwiftUI Views using SnapshotTesting. Use when creating visual regression tests for views with CachedAsyncImage support.
---

# Skill: Snapshot Tests

Guide for creating Snapshot Tests using Point-Free's SnapshotTesting library with image mocking support.

## When to use this skill

- Create snapshot tests for a View
- Test different view states visually (loading, loaded, empty, error)
- Ensure visual regression prevention
- Test views that contain images (using CachedAsyncImage)

## Prerequisites

The project must have:
1. `SnapshotTesting` dependency in test targets (configured in `Project.swift`)
2. `CachedAsyncImage` component in Core module (replaces `AsyncImage`)
3. `ImageLoaderMock` in CoreMocks module
4. Test image resource in `Tests/Resources/` directory

---

## File structure

```
Libraries/Features/{FeatureName}/
├── Sources/
│   └── Presentation/
│       └── {Name}/
│           ├── Views/
│           │   └── {Name}View.swift           # Uses CachedAsyncImage
│           └── ViewModels/
│               ├── {Name}ViewModel.swift
│               ├── {Name}ViewModelContract.swift  # Protocol for testability
│               └── {Name}ViewState.swift
└── Tests/
    └── Presentation/
        ├── Helpers/
        │   ├── {Name}ViewModelStub.swift      # Stub with fixed state
        │   └── SnapshotStubs.swift            # Test image loader
        └── {Name}/
            └── Snapshots/
                ├── {Name}ViewSnapshotTests.swift
                └── __Snapshots__/             # Auto-generated
                    └── {Name}ViewSnapshotTests/
                        ├── loadingState.1.png
                        ├── loadedState.1.png
                        └── errorState.1.png
```

---

## CachedAsyncImage (Core Module)

Views must use `CachedAsyncImage` instead of `AsyncImage` to support image mocking in tests:

```swift
// In View file
import ChallengeCore

struct CharacterDetailView: View {
    var body: some View {
        CachedAsyncImage(url: character.imageURL) { image in
            image
                .resizable()
                .scaledToFill()
        } placeholder: {
            ProgressView()
        }
        .frame(width: 150, height: 150)
    }
}
```

**Key differences from AsyncImage:**
- Supports dependency injection via Environment
- Checks for cached/mock images synchronously first
- Falls back to async loading if no cached image

---

## ViewModel Contract (for snapshot tests)

Create a protocol for the ViewModel to enable stub injection:

```swift
// Sources/Presentation/{Name}/ViewModels/{Name}ViewModelContract.swift
import Foundation

protocol {Name}ViewModelContract: AnyObject {
    var state: {Name}ViewState { get }
    func load() async
    // Add other methods the view calls
}
```

Make the ViewModel conform:

```swift
// Sources/Presentation/{Name}/ViewModels/{Name}ViewModel.swift
@Observable
final class {Name}ViewModel: {Name}ViewModelContract {
    // Implementation...
}
```

Make the View generic over the protocol:

```swift
// Sources/Presentation/{Name}/Views/{Name}View.swift
struct {Name}View<ViewModel: {Name}ViewModelContract>: View {
    @State private var viewModel: ViewModel

    init(viewModel: ViewModel) {
        _viewModel = State(initialValue: viewModel)
    }
    // ...
}
```

---

## ViewModel Stub (for fixed state)

Create a stub that returns a fixed state without executing any logic:

```swift
// Tests/Presentation/Helpers/{Name}ViewModelStub.swift
import Foundation

@testable import Challenge{Feature}

@Observable
final class {Name}ViewModelStub: {Name}ViewModelContract {
    var state: {Name}ViewState

    init(state: {Name}ViewState) {
        self.state = state
    }

    func load() async { }
    // Implement other protocol methods as no-ops
}
```

**Rules:**
- All methods are no-ops (empty implementation)
- State is injected via init and never changes
- Marked `@Observable` for SwiftUI compatibility

---

## SnapshotStubs (Test Image)

Provides the test image for mocking:

```swift
// Tests/Presentation/Helpers/SnapshotStubs.swift
import Foundation
import UIKit

enum SnapshotStubs {
    static var testImage: UIImage? {
        guard let path = Bundle.module.path(forResource: "test-avatar", ofType: "jpg") else {
            return nil
        }
        return UIImage(contentsOfFile: path)
    }
}
```

**Requirements:**
- Place test image at `Tests/Resources/test-avatar.jpg`
- Use `Bundle.module` (auto-generated by Tuist)
- Match the file extension to actual file type (jpg, png)

---

## Snapshot Test Structure

```swift
// Tests/Presentation/{Name}/Snapshots/{Name}ViewSnapshotTests.swift
import ChallengeCoreMocks
import SnapshotTesting
import SwiftUI
import Testing

@testable import Challenge{Feature}

struct {Name}ViewSnapshotTests {
    private let imageLoader: ImageLoaderMock

    init() {
        UIView.setAnimationsEnabled(false)
        imageLoader = ImageLoaderMock(image: SnapshotStubs.testImage)
    }

    // MARK: - Loading State

    @Test
    func loadingState() {
        // Given
        let viewModel = {Name}ViewModelStub(state: .loading)

        // When
        let view = NavigationStack {
            {Name}View(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    // MARK: - Loaded State

    @Test
    func loadedState() {
        // Given
        let data = {Model}.stub()
        let viewModel = {Name}ViewModelStub(state: .loaded(data))

        // When
        let view = NavigationStack {
            {Name}View(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    // MARK: - Error State

    @Test
    func errorState() {
        // Given
        let viewModel = {Name}ViewModelStub(state: .error(SnapshotTestError.failed))

        // When
        let view = NavigationStack {
            {Name}View(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }
}

// MARK: - Test Helpers

private enum SnapshotTestError: LocalizedError {
    case failed

    var errorDescription: String? {
        "Something went wrong"
    }
}
```

---

## Key Rules

### Test Setup

1. **Disable animations** - `UIView.setAnimationsEnabled(false)` in init
2. **Create ImageLoaderMock** - With `SnapshotStubs.testImage` in init
3. **Inject imageLoader** - Use `.imageLoader(imageLoader)` modifier on view

### View Configuration

1. **Wrap in NavigationStack** - Required for navigation-dependent views
2. **Use consistent device** - `.iPhone13ProMax` for all snapshots
3. **Apply imageLoader modifier** - After NavigationStack, before assertSnapshot

### Test Structure

1. **Given** - Create stub with specific state
2. **When** - Create view with stub and imageLoader
3. **Then** - Assert snapshot with device layout

### Naming Conventions

- Test file: `{Name}ViewSnapshotTests.swift`
- Test method: `{stateName}State()` (e.g., `loadingState`, `loadedStateAlive`)
- Snapshots folder: `__Snapshots__/{Name}ViewSnapshotTests/`

---

## Example: CharacterDetailViewSnapshotTests

```swift
import ChallengeCoreMocks
import SnapshotTesting
import SwiftUI
import Testing

@testable import ChallengeCharacter

struct CharacterDetailViewSnapshotTests {
    private let imageLoader: ImageLoaderMock

    init() {
        UIView.setAnimationsEnabled(false)
        imageLoader = ImageLoaderMock(image: SnapshotStubs.testImage)
    }

    @Test
    func loadingState() {
        // Given
        let viewModel = CharacterDetailViewModelStub(state: .loading)

        // When
        let view = NavigationStack {
            CharacterDetailView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    @Test
    func loadedStateAliveCharacter() {
        // Given
        let character = Character.stub(
            name: "Rick Sanchez",
            status: .alive,
            species: "Human",
            gender: "Male"
        )
        let viewModel = CharacterDetailViewModelStub(state: .loaded(character))

        // When
        let view = NavigationStack {
            CharacterDetailView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    @Test
    func loadedStateDeadCharacter() {
        // Given
        let character = Character.stub(
            name: "Birdperson",
            status: .dead,
            species: "Birdperson"
        )
        let viewModel = CharacterDetailViewModelStub(state: .loaded(character))

        // When
        let view = NavigationStack {
            CharacterDetailView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    @Test
    func errorState() {
        // Given
        let viewModel = CharacterDetailViewModelStub(state: .error(SnapshotTestError.loadFailed))

        // When
        let view = NavigationStack {
            CharacterDetailView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }
}

private enum SnapshotTestError: LocalizedError {
    case loadFailed

    var errorDescription: String? {
        "Failed to load character details"
    }
}
```

---

## Example: CharacterListViewSnapshotTests

```swift
import ChallengeCoreMocks
import SnapshotTesting
import SwiftUI
import Testing

@testable import ChallengeCharacter

struct CharacterListViewSnapshotTests {
    private let imageLoader: ImageLoaderMock

    init() {
        UIView.setAnimationsEnabled(false)
        imageLoader = ImageLoaderMock(image: SnapshotStubs.testImage)
    }

    @Test
    func loadingState() {
        // Given
        let viewModel = CharacterListViewModelStub(state: .loading)

        // When
        let view = NavigationStack {
            CharacterListView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    @Test
    func loadedStateWithCharacters() {
        // Given
        let page = CharactersPage.stub(
            characters: [
                .stub(id: 1, name: "Rick Sanchez", status: .alive),
                .stub(id: 2, name: "Morty Smith", status: .alive),
                .stub(id: 3, name: "Summer Smith", status: .dead)
            ]
        )
        let viewModel = CharacterListViewModelStub(state: .loaded(page))

        // When
        let view = NavigationStack {
            CharacterListView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    @Test
    func emptyState() {
        // Given
        let viewModel = CharacterListViewModelStub(state: .empty)

        // When
        let view = NavigationStack {
            CharacterListView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }

    @Test
    func errorState() {
        // Given
        let viewModel = CharacterListViewModelStub(state: .error(SnapshotTestError.networkError))

        // When
        let view = NavigationStack {
            CharacterListView(viewModel: viewModel)
        }
        .imageLoader(imageLoader)

        // Then
        assertSnapshot(of: view, as: .image(layout: .device(config: .iPhone13ProMax)))
    }
}

private enum SnapshotTestError: LocalizedError {
    case networkError

    var errorDescription: String? {
        "Unable to connect to the server"
    }
}
```

---

## Tuist Configuration

### Test Dependencies (Project.swift)

```swift
let characterModule = FrameworkModule.create(
    name: "Character",
    path: "Features/Character",
    dependencies: [
        .target(name: "\(appName)Core"),
        .target(name: "\(appName)Networking"),
    ],
    testDependencies: [
        .target(name: "\(appName)CoreMocks"),
        .target(name: "\(appName)NetworkingMocks"),
        .external(name: "SnapshotTesting"),
    ],
    hasMocks: false
)
```

### Test Resources (FrameworkModule.swift)

Resources are automatically included via:

```swift
let tests = Target.target(
    name: testsTargetName,
    // ...
    resources: [.glob(pattern: "Libraries/\(sourcesPath)/Tests/Resources/**", excluding: [])],
    // ...
)
```

---

## Running Snapshot Tests

### First Run (Recording)

```bash
tuist test {Module}
# or
xcodebuild test -workspace Challenge.xcworkspace -scheme {Module} -destination 'platform=iOS Simulator,name=iPhone 16 Pro'
```

First run creates reference snapshots and **fails** (expected behavior).

### Subsequent Runs (Comparison)

Run again to compare against recorded snapshots:

```bash
tuist test {Module}
```

Tests pass if snapshots match references.

### Regenerating Snapshots

Delete the `__Snapshots__` folder and run tests:

```bash
rm -rf Libraries/Features/{Feature}/Tests/Presentation/{Name}/Snapshots/__Snapshots__
tuist test {Module}
# Run twice: first to record, second to verify
tuist test {Module}
```

---

## Checklist

### Setup (once per feature)

- [ ] Add `SnapshotTesting` to testDependencies in Project.swift
- [ ] Create `Tests/Resources/test-avatar.jpg` with test image
- [ ] Create `SnapshotStubs.swift` in `Tests/Presentation/Helpers/`
- [ ] Create ViewModel protocol (`{Name}ViewModelContract.swift`)
- [ ] Make ViewModel conform to protocol
- [ ] Make View generic over protocol
- [ ] Create ViewModel stub (`{Name}ViewModelStub.swift`)

### Per View

- [ ] Replace `AsyncImage` with `CachedAsyncImage` in View
- [ ] Create `{Name}ViewSnapshotTests.swift`
- [ ] Import `ChallengeCoreMocks` and `SnapshotTesting`
- [ ] Initialize `ImageLoaderMock` with `SnapshotStubs.testImage`
- [ ] Disable animations in init
- [ ] Create test for each state (loading, loaded, empty, error)
- [ ] Inject `.imageLoader(imageLoader)` on all views
- [ ] Use `.iPhone13ProMax` device config
- [ ] Run tests twice to record and verify
