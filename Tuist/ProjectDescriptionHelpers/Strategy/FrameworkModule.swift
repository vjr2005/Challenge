import ProjectDescription

/// Module implementation that integrates as a framework target in the root project.
///
/// Each module produces framework targets (source, mocks, unit tests, snapshot tests)
/// and a per-module scheme. Dependencies are resolved from the init parameters.
/// Tests run via `.targets(...)` with explicit testable targets and coverage.
public struct FrameworkModule: ModuleContract, @unchecked Sendable {
	public let directory: String
	public let name: String
	public let includeInCoverage: Bool

	// MARK: - Framework: Stored

	public let targets: [Target]
	public let schemes: [Scheme]
	public let testableTargets: [TestableTarget]
	public let codeCoverageTargets: [TargetReference]

	// MARK: - Framework: Computed (derived from name)

	public var targetDependency: TargetDependency { .target(name: name) }
	public var mocksTargetDependency: TargetDependency { .target(name: "\(name)Mocks") }
	public let packageReference: Package? = nil
	public let packageTargetSettings: [String: Settings] = [:]

	// MARK: - Init

	public init(
		directory: String,
		dependencies: [ModuleDependency] = [],
		testDependencies: [ModuleDependency] = [],
		snapshotTestDependencies: [ModuleDependency] = [],
		includeInCoverage: Bool = true,
		settingsOverrides: SettingsDictionary = [:],
		config: ProjectConfig = projectConfig
	) {
		let fileSystem = ModuleFileSystem(directory: directory, appName: config.appName)
		let name = fileSystem.targetName
		self.directory = directory
		self.name = name
		self.includeInCoverage = includeInCoverage

		let pathPrefix = "\(directory)/"
		let settings: Settings = .settings(
			base: config.baseSettings.merging(settingsOverrides) { _, new in new }
		)

		var targets: [Target] = [
			Self.makeFrameworkTarget(
				name: name,
				pathPrefix: pathPrefix,
				fileSystem: fileSystem,
				dependencies: dependencies,
				settings: settings,
				destinations: config.destinations,
				deploymentTargets: config.developmentTarget
			),
		]
		var testsDependencies: [TargetDependency] = [.target(name: name)]
		var testableTargets: [TestableTarget] = []
		var buildTargets: [TargetReference] = [.target(name)]

		if fileSystem.hasMocks {
			targets.append(
				Self.makeMocksTarget(
					name: name,
					pathPrefix: pathPrefix,
					settings: settings,
					destinations: config.destinations,
					deploymentTargets: config.developmentTarget
				)
			)
			testsDependencies.append(.target(name: "\(name)Mocks"))
		}

		if fileSystem.hasUnitTests {
			let testsTargetName = "\(name)Tests"
			targets.append(
				Self.makeUnitTestsTarget(
					name: name,
					testsTargetName: testsTargetName,
					pathPrefix: pathPrefix,
					fileSystem: fileSystem,
					testsDependencies: testsDependencies,
					testDependencies: testDependencies,
					settings: settings,
					destinations: config.destinations,
					deploymentTargets: config.developmentTarget
				)
			)
			testableTargets.append(
				.testableTarget(
					target: .target(testsTargetName),
					parallelization: .swiftTestingOnly
				)
			)
			buildTargets.append(.target(testsTargetName))
		}

		if fileSystem.hasSnapshotTests {
			let snapshotTestsTargetName = "\(name)SnapshotTests"
			targets.append(
				Self.makeSnapshotTestsTarget(
					name: name,
					snapshotTestsTargetName: snapshotTestsTargetName,
					pathPrefix: pathPrefix,
					fileSystem: fileSystem,
					testsDependencies: testsDependencies,
					snapshotTestDependencies: snapshotTestDependencies,
					settings: settings,
					destinations: config.destinations,
					deploymentTargets: config.developmentTarget
				)
			)
			testableTargets.append(
				.testableTarget(
					target: .target(snapshotTestsTargetName),
					parallelization: .swiftTestingOnly
				)
			)
			buildTargets.append(.target(snapshotTestsTargetName))
		}

		self.targets = targets
		self.schemes = [Self.makeScheme(name: name, testableTargets: testableTargets, buildTargets: buildTargets)]
		self.testableTargets = testableTargets
		self.codeCoverageTargets = includeInCoverage ? [.target(name)] : []
	}
}

// MARK: - Aggregation

extension FrameworkModule {
	static func aggregateTestAction(
		modules: [any ModuleContract],
		appTargetReference: TargetReference
	) -> TestAction {
		let testableTargets = modules.flatMap(\.testableTargets)
		let codeCoverageTargets: [TargetReference] = [appTargetReference]
			+ modules.flatMap(\.codeCoverageTargets)

		return .targets(
			testableTargets,
			options: .options(
				coverage: true,
				codeCoverageTargets: codeCoverageTargets
			)
		)
	}

	static func aggregateCoverageMode(
		modules: [any ModuleContract],
		appTargetReference: TargetReference
	) -> Workspace.GenerationOptions.AutogeneratedWorkspaceSchemes.CodeCoverageMode {
		let codeCoverageTargets = modules.flatMap(\.codeCoverageTargets)
		return .targets([appTargetReference] + codeCoverageTargets)
	}
}

// MARK: - Private Helpers

extension FrameworkModule {
	private static func makeFrameworkTarget(
		name: String,
		pathPrefix: String,
		fileSystem: ModuleFileSystem,
		dependencies: [ModuleDependency],
		settings: Settings,
		destinations: ProjectDescription.Destinations,
		deploymentTargets: DeploymentTargets
	) -> Target {
		let resources: ResourceFileElements? = fileSystem.hasResources ? [
			.glob(pattern: "\(pathPrefix)Sources/Resources/**", excluding: []),
		] : nil

		return .target(
			name: name,
			destinations: destinations,
			product: .framework,
			bundleId: "${PRODUCT_BUNDLE_IDENTIFIER}.\(name)",
			deploymentTargets: deploymentTargets,
			sources: ["\(pathPrefix)Sources/**"],
			resources: resources,
			scripts: [SwiftLint.script(path: "\(pathPrefix)Sources", workspaceRoot: ".")],
			dependencies: dependencies.map(\.targetDependency),
			settings: settings
		)
	}

	private static func makeMocksTarget(
		name: String,
		pathPrefix: String,
		settings: Settings,
		destinations: ProjectDescription.Destinations,
		deploymentTargets: DeploymentTargets
	) -> Target {
		.target(
			name: "\(name)Mocks",
			destinations: destinations,
			product: .framework,
			bundleId: "${PRODUCT_BUNDLE_IDENTIFIER}.\(name)Mocks",
			deploymentTargets: deploymentTargets,
			sources: ["\(pathPrefix)Mocks/**"],
			dependencies: [.target(name: name)],
			settings: settings
		)
	}

	private static func makeUnitTestsTarget(
		name: String,
		testsTargetName: String,
		pathPrefix: String,
		fileSystem: ModuleFileSystem,
		testsDependencies: [TargetDependency],
		testDependencies: [ModuleDependency],
		settings: Settings,
		destinations: ProjectDescription.Destinations,
		deploymentTargets: DeploymentTargets
	) -> Target {
		let unitSources: SourceFilesList = fileSystem.hasSharedTests
			? ["\(pathPrefix)Tests/Unit/**", "\(pathPrefix)Tests/Shared/**"]
			: ["\(pathPrefix)Tests/Unit/**"]

		let unitResources: ResourceFileElements = fileSystem.hasSharedTests ? [
			.glob(pattern: "\(pathPrefix)Tests/Shared/Resources/**", excluding: []),
			.glob(pattern: "\(pathPrefix)Tests/Shared/Fixtures/**", excluding: []),
		] : []

		return .target(
			name: testsTargetName,
			destinations: destinations,
			product: .unitTests,
			bundleId: "${PRODUCT_BUNDLE_IDENTIFIER}.\(testsTargetName)",
			deploymentTargets: deploymentTargets,
			sources: unitSources,
			resources: unitResources,
			dependencies: testsDependencies + testDependencies.map(\.targetDependency),
			settings: settings
		)
	}

	private static func makeSnapshotTestsTarget(
		name: String,
		snapshotTestsTargetName: String,
		pathPrefix: String,
		fileSystem: ModuleFileSystem,
		testsDependencies: [TargetDependency],
		snapshotTestDependencies: [ModuleDependency],
		settings: Settings,
		destinations: ProjectDescription.Destinations,
		deploymentTargets: DeploymentTargets
	) -> Target {
		let snapshotSources: SourceFilesList = fileSystem.hasSharedTests
			? ["\(pathPrefix)Tests/Snapshots/**", "\(pathPrefix)Tests/Shared/**"]
			: ["\(pathPrefix)Tests/Snapshots/**"]

		let snapshotResources: ResourceFileElements = fileSystem.hasSharedTests ? [
			.glob(pattern: "\(pathPrefix)Tests/Shared/Resources/**", excluding: []),
		] : []

		let snapshotDeps = testsDependencies
			+ snapshotTestDependencies.map(\.targetDependency)

		return .target(
			name: snapshotTestsTargetName,
			destinations: destinations,
			product: .unitTests,
			bundleId: "${PRODUCT_BUNDLE_IDENTIFIER}.\(snapshotTestsTargetName)",
			deploymentTargets: deploymentTargets,
			sources: snapshotSources,
			resources: snapshotResources,
			dependencies: snapshotDeps,
			settings: settings
		)
	}

	private static func makeScheme(
		name: String,
		testableTargets: [TestableTarget],
		buildTargets: [TargetReference]
	) -> Scheme {
		if !testableTargets.isEmpty {
			return .scheme(
				name: name,
				buildAction: .buildAction(targets: buildTargets),
				testAction: .targets(
					testableTargets,
					options: .options(
						coverage: true,
						codeCoverageTargets: [.target(name)]
					)
				)
			)
		} else {
			return .scheme(
				name: name,
				buildAction: .buildAction(targets: [.target(name)])
			)
		}
	}
}
