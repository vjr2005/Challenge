import ProjectDescription

/// Unified aggregation logic for module collections.
///
/// Always uses `.testPlans(...)` with an auto-generated test plan, regardless
/// of the active module strategy. This ensures the `xcodebuild test` command
/// is the same for both `FrameworkModule` and `SPMModule`, so CI never needs
/// to change when switching strategies.
enum ModuleAggregation {
	/// Generates a test action for the aggregate Dev scheme.
	///
	/// Always generates a test plan via `TestPlanGenerator` and references it
	/// as a string path. The test plan is the default in the scheme, so
	/// `xcodebuild test -scheme "Challenge (Dev)"` picks it up automatically.
	static func aggregateTestAction(
		modules: [any ModuleContract],
		appTargetReference: TargetReference,
		config: ProjectConfig = projectConfig
	) -> TestAction {
		let testPlanName = TestPlanGenerator.generate(
			appName: config.appName,
			modules: modules
		)
		return .testPlans([Path(stringLiteral: testPlanName)])
	}

	/// Generates coverage mode for workspace autogenerated schemes.
	///
	/// Uses `.relevant` so coverage is driven by the test plan's
	/// `codeCoverageTargets`, keeping it consistent across strategies.
	static func aggregateCoverageMode(
		modules: [any ModuleContract],
		appTargetReference: TargetReference
	) -> Workspace.GenerationOptions.AutogeneratedWorkspaceSchemes.CodeCoverageMode {
		.relevant
	}
}
