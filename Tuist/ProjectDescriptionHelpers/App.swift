import ProjectDescription

/// Configuration and targets for the main app project.
public struct App: @unchecked Sendable {
	// MARK: - Configuration

	public let name: String
	public let bundleId: String
	public let appDestinations: ProjectDescription.Destinations
	public let appDeploymentTarget: DeploymentTargets
	public let baseSettings: SettingsDictionary
	public let infoPlist: [String: Plist.Value]
	public let modules: [Module]
	public let entryModule: Module

	public init(
		name: String,
		bundleId: String,
		destinations: ProjectDescription.Destinations,
		developmentTarget: DeploymentTargets,
		baseSettings: SettingsDictionary,
		infoPlist: [String: Plist.Value],
		modules: [Module],
		entryModule: Module
	) {
		self.name = name
		self.bundleId = bundleId
		self.appDestinations = destinations
		self.appDeploymentTarget = developmentTarget
		self.baseSettings = baseSettings
		self.infoPlist = infoPlist
		self.modules = modules
		self.entryModule = entryModule
	}

	// MARK: - Module Aggregation

	/// Package references for the project. SPM: one per module. Framework: empty.
	var packages: [Package] {
		modules.compactMap(\.packageReference)
	}

	/// Framework targets for the project. SPM: empty. Framework: all module targets.
	var moduleTargets: [Target] {
		modules.flatMap(\.targets)
	}

	/// Per-module schemes. SPM: empty. Framework: one scheme per module.
	var moduleSchemes: [Scheme] {
		modules.flatMap(\.schemes)
	}

	/// Test action for the Dev scheme. Delegated to the active module strategy.
	var devTestAction: TestAction {
		Module.aggregateTestAction(modules: modules, appTargetReference: targetReference)
	}

	/// Code coverage mode for workspace autogenerated schemes. Delegated to the active module strategy.
	public var coverageMode: Workspace.GenerationOptions.AutogeneratedWorkspaceSchemes.CodeCoverageMode {
		Module.aggregateCoverageMode(modules: modules, appTargetReference: targetReference)
	}

	/// Per-target build settings for `Tuist/Package.swift`.
	/// Aggregated from each module. SPM: one entry per detected target. Framework: empty.
	public var packageTargetSettings: [String: Settings] {
		var result: [String: Settings] = [:]
		for module in modules {
			result.merge(module.packageTargetSettings) { _, new in new }
		}
		return result
	}

	// MARK: - Target References

	var targetReference: TargetReference {
		.target(name)
	}

	var uiTestsTargetReference: TargetReference {
		.target("\(name)UITests")
	}

	// MARK: - Targets

	private var appTarget: Target {
		.target(
			name: name,
			destinations: appDestinations,
			product: .app,
			bundleId: bundleId,
			deploymentTargets: appDeploymentTarget,
			infoPlist: .extendingDefault(with: infoPlist),
			sources: ["App/Sources/**"],
			resources: ["App/Sources/Resources/**"],
			scripts: [SwiftLint.script(path: "App/Sources")],
			dependencies: [entryModule.targetDependency],
			settings: .settings(
				configurations: Environment.appTargetConfigurations,
				defaultSettings: .recommended
			)
		)
	}

	private var uiTestsTarget: Target {
		.target(
			name: "\(name)UITests",
			destinations: appDestinations,
			product: .uiTests,
			bundleId: "\(bundleId)UITests",
			deploymentTargets: appDeploymentTarget,
			infoPlist: .default,
			sources: [
				"App/Tests/UI/**",
				"App/Tests/Shared/**",
			],
			resources: [
				"App/Tests/Shared/Fixtures/**",
				"App/Tests/Shared/Resources/**",
			],
			dependencies: [
				.target(name: name),
				.external(name: "SwiftMockServerBinary"),
			]
		)
	}

	// MARK: - Schemes

	private func scheme(for environment: Environment, includeTests: Bool = false) -> Scheme {
		.scheme(
			name: environment.schemeName,
			buildAction: .buildAction(targets: [targetReference]),
			testAction: includeTests ? devTestAction : nil,
			runAction: .runAction(
				configuration: environment.debugConfigurationName,
				executable: targetReference
			),
			archiveAction: .archiveAction(configuration: environment.releaseConfigurationName),
			profileAction: .profileAction(
				configuration: environment.releaseConfigurationName,
				executable: targetReference
			),
			analyzeAction: .analyzeAction(configuration: environment.debugConfigurationName)
		)
	}

	private var uiTestsScheme: Scheme {
		.scheme(
			name: "\(name)UITests",
			buildAction: .buildAction(targets: [targetReference, uiTestsTargetReference]),
			testAction: .targets(
				[
					.testableTarget(
						target: uiTestsTargetReference
					),
				],
				options: .options(
					preferredScreenCaptureFormat: .screenRecording,
					coverage: true,
					codeCoverageTargets: [targetReference]
				)
			)
		)
	}

	private var allSchemes: [Scheme] {
		Environment.allCases.map { environment in
			scheme(for: environment, includeTests: environment == .dev)
		}
	}

	// MARK: - Project

	/// The main app project.
	public var project: Project {
		Project(
			name: name,
			options: .options(
				automaticSchemesOptions: .disabled,
				developmentRegion: "en",
				disableBundleAccessors: false,
				disableSynthesizedResourceAccessors: true
			),
			packages: packages,
			settings: .settings(
				base: baseSettings.merging([
					"SWIFT_EMIT_LOC_STRINGS": .string("YES"),
				]) { _, new in new },
				configurations: BuildConfiguration.all
			),
			targets: [appTarget, uiTestsTarget] + moduleTargets,
			schemes: allSchemes + [uiTestsScheme] + moduleSchemes
		)
	}
}
