name: Quality Checks

on:
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  unit-and-snapshot-tests:
    name: Unit & Snapshot Tests
    runs-on: macos-15
    timeout-minutes: 40

    env:
      TUIST_TEST_DEVICE: iPhone 17 Pro
      TUIST_TEST_OS: "26.1"
      DERIVED_DATA_PATH: derived_data
      RESULT_BUNDLE_PATH: test_output/UnitSnapshot.xcresult

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          device: ${{ env.TUIST_TEST_DEVICE }}
          derived-data-prefix: unit

      - name: Run unit and snapshot tests
        timeout-minutes: 35
        run: |
          mise x -- tuist test "Challenge (Dev)" \
            --device "$TUIST_TEST_DEVICE" \
            --os "$TUIST_TEST_OS" \
            --result-bundle-path "$RESULT_BUNDLE_PATH" \
            -- -derivedDataPath "$DERIVED_DATA_PATH" \
            -retry-tests-on-failure

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: unit-snapshot-coverage
          path: test_output
          retention-days: 1

      - name: Test report
        if: failure()
        uses: ./.github/actions/test-report
        with:
          title: Unit & Snapshot Test Results
          artifact-name: unit-snapshot-results
          result-bundle-path: ${{ env.RESULT_BUNDLE_PATH }}

      - name: Detect dead code
        id: periphery
        continue-on-error: true
        run: |
          set +e
          INDEX_STORE="${DERIVED_DATA_PATH}/Index.noindex/DataStore"
          if [ -d "$INDEX_STORE" ]; then
            echo "Reusing index store: $INDEX_STORE"
            OUTPUT=$(mise x -- periphery scan --skip-build --index-store-path "$INDEX_STORE" 2>&1)
          else
            echo "Index store not found, running full build"
            OUTPUT=$(mise x -- periphery scan 2>&1)
          fi
          echo "$OUTPUT"
          echo 'PERIPHERY_OUTPUT<<PERIPHERY_EOF' >> "$GITHUB_ENV"
          echo "$OUTPUT" >> "$GITHUB_ENV"
          echo 'PERIPHERY_EOF' >> "$GITHUB_ENV"

      - name: Periphery summary
        id: periphery-summary
        uses: actions/github-script@v7
        with:
          script: |
            const raw = process.env.PERIPHERY_OUTPUT || '';
            const output = raw.replace(/\x1b\[[0-9;]*m/g, '');

            const diagnosticRegex = /^(.+?):(\d+):(\d+):\s+warning:\s+(.+)$/gm;
            const findings = [];
            let match;
            while ((match = diagnosticRegex.exec(output)) !== null) {
              findings.push({
                file: match[1],
                line: match[2],
                description: match[4]
              });
            }

            let body;
            if (findings.length === 0) {
              body = [
                '## Periphery \u2014 Dead code detection',
                '',
                ':white_check_mark: No unused code detected.'
              ].join('\n');
            } else {
              const rows = findings.map(f => {
                const shortFile = f.file.replace(/^.*?(?=Features\/|Sources\/|Tests\/)/, '');
                return `| :warning: | \`${shortFile}\` | ${f.line} | ${f.description} |`;
              });

              body = [
                '## Periphery \u2014 Dead code detection',
                '',
                `Found **${findings.length}** unused code occurrence(s):`,
                '',
                '| | File | Line | Description |',
                '|---|------|------|-------------|',
                ...rows
              ].join('\n');
            }

            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, body + '\n');

            core.setOutput('body', body);

      - name: Comment PR with Periphery results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${{ steps.periphery-summary.outputs.body }}`
            });

  ui-tests:
    name: UI Tests
    runs-on: macos-15
    timeout-minutes: 40

    env:
      TUIST_TEST_DEVICE: iPhone 17 Pro
      TUIST_TEST_OS: "26.1"
      DERIVED_DATA_PATH: derived_data
      RESULT_BUNDLE_PATH: test_output/UITests.xcresult

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          device: ${{ env.TUIST_TEST_DEVICE }}
          derived-data-prefix: ui

      - name: Run UI tests
        timeout-minutes: 35
        run: |
          mise x -- tuist test "ChallengeUITests" \
            --device "$TUIST_TEST_DEVICE" \
            --os "$TUIST_TEST_OS" \
            --result-bundle-path "$RESULT_BUNDLE_PATH" \
            -- -derivedDataPath "$DERIVED_DATA_PATH" \
            -retry-tests-on-failure \
            -test-repetition-relaunch-enabled YES

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-coverage
          path: test_output
          retention-days: 1

      - name: Upload test results
        id: upload-results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-results
          path: test_output
          retention-days: 7

      - name: UI Tests summary
        id: ui-summary
        if: always()
        shell: bash
        run: |
          python3 << 'PYEOF'
          import json, subprocess, os

          result_bundle = os.environ['RESULT_BUNDLE_PATH']
          xcresult_url = os.environ.get('XCRESULT_URL', '')
          if not os.path.isdir(result_bundle):
              exit(0)

          result = subprocess.run(
              ['xcrun', 'xcresulttool', 'get', 'test-results', 'tests',
               '--path', result_bundle],
              capture_output=True, text=True
          )
          if result.returncode != 0:
              exit(0)

          data = json.loads(result.stdout)
          failures = []
          retried = []

          def walk(node, parts):
              name = node.get('name', '')
              node_type = node.get('nodeType', '')

              if node_type in ('Test Plan', 'UI test bundle'):
                  for child in node.get('children', []):
                      walk(child, [])
                  return

              if node_type == 'Test Suite':
                  for child in node.get('children', []):
                      walk(child, parts + [name] if name else parts)
                  return

              current = parts + [name] if name else parts

              if node_type == 'Test Case':
                  children = node.get('children', [])
                  runs = [c for c in children if c.get('result') in ('Passed', 'Failed')]
                  if runs:
                      failed_runs = [r for r in runs if r.get('result') == 'Failed']
                      if failed_runs:
                          retried.append({
                              'test': '/'.join(current),
                              'attempts': len(runs),
                              'failed_attempts': len(failed_runs),
                              'final_result': node.get('result', 'Unknown')
                          })
                  if node.get('result') == 'Failed':
                      failures.append('/'.join(current))
                  return

              for child in node.get('children', []):
                  walk(child, current)

          for node in data.get('testNodes', []):
              walk(node, [])

          if not failures and not retried:
              exit(0)

          lines = ['## UI Test Results', '']

          if failures:
              lines += [':x: **Tests failed.**', '', '| | Test |', '|---|------|']
              lines += [f'| :x: | `{f}` |' for f in failures]
              lines.append('')

          if retried:
              if failures:
                  lines.append('### Retried Tests')
                  lines.append('')
              lines += [
                  f':warning: **{len(retried)} test(s) required retry:**',
                  '',
                  '| | Test | Attempts | Result |',
                  '|---|------|----------|--------|'
              ]
              for r in retried:
                  icon = ':white_check_mark:' if r['final_result'] == 'Passed' else ':x:'
                  lines.append(f"| {icon} | `{r['test']}` | {r['attempts']} | {r['final_result']} |")
              lines += ['', '_These tests failed initially and were retried via `-retry-tests-on-failure`._']

          if xcresult_url:
              lines += ['', f':package: [Download xcresult]({xcresult_url})', '',
                        '_Open the `.xcresult` file in Xcode to inspect failures._']

          body = '\n'.join(lines)

          with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as summary:
              summary.write(body + '\n')

          with open(os.environ['GITHUB_OUTPUT'], 'a') as output:
              output.write('body<<UI_SUMMARY_EOF\n')
              output.write(body + '\n')
              output.write('UI_SUMMARY_EOF\n')
              output.write('has_info=true\n')
          PYEOF
        env:
          XCRESULT_URL: ${{ steps.upload-results.outputs.artifact-url }}

      - name: Comment PR with UI test summary
        if: github.event_name == 'pull_request' && steps.ui-summary.outputs.has_info == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${{ steps.ui-summary.outputs.body }}`
            });

  quality-gate:
    name: Quality Gate
    runs-on: macos-15
    needs: [unit-and-snapshot-tests, ui-tests]
    if: always()
    timeout-minutes: 10

    env:
      COVERAGE_THRESHOLD: 80

    steps:
      - name: Check job results
        run: |
          echo "Unit & Snapshot Tests: ${{ needs.unit-and-snapshot-tests.result }}"
          echo "UI Tests: ${{ needs.ui-tests.result }}"
          if [ "${{ needs.unit-and-snapshot-tests.result }}" != "success" ] || [ "${{ needs.ui-tests.result }}" != "success" ]; then
            echo "::error::One or more test jobs failed"
            exit 1
          fi

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-coverage'

      - name: Merge coverage data
        run: |
          mkdir -p merged-output
          xcrun xcresulttool merge \
            unit-snapshot-coverage/UnitSnapshot.xcresult \
            ui-test-coverage/UITests.xcresult \
            --output-path merged-output/merged.xcresult
          xcrun xccov view --report --json merged-output/merged.xcresult > coverage.json

      - name: Upload merged xcresult
        id: upload-xcresult
        uses: actions/upload-artifact@v4
        with:
          name: merged-xcresult
          path: merged-output
          retention-days: 7

      - name: Coverage report
        id: coverage
        uses: actions/github-script@v7
        env:
          THRESHOLD: ${{ env.COVERAGE_THRESHOLD }}
          XCRESULT_ARTIFACT_ID: ${{ steps.upload-xcresult.outputs.artifact-id }}
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('coverage.json', 'utf8'));
            const THRESHOLD = parseInt(process.env.THRESHOLD, 10);

            const targets = report.targets.filter(t =>
              (t.name.endsWith('.framework') || t.name.endsWith('.app')) &&
              !t.name.includes('Mock') &&
              !t.name.includes('Test')
            );

            let totalCovered = 0;
            let totalExecutable = 0;

            const rows = targets
              .sort((a, b) => a.name.localeCompare(b.name))
              .map(t => {
                totalCovered += t.coveredLines;
                totalExecutable += t.executableLines;
                const pct = (t.lineCoverage * 100).toFixed(1);
                const icon = parseFloat(pct) >= THRESHOLD ? ':white_check_mark:' : ':x:';
                const name = t.name.replace(/\.(framework|app)$/, '');
                return `| ${icon} | ${name} | ${t.coveredLines} / ${t.executableLines} | ${pct}% |`;
              });

            const totalPct = totalExecutable > 0
              ? (totalCovered / totalExecutable * 100)
              : 0;
            const totalIcon = totalPct >= THRESHOLD ? ':white_check_mark:' : ':x:';

            const artifactId = process.env.XCRESULT_ARTIFACT_ID;
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}/artifacts/${artifactId}`;

            const body = [
              '## Code Coverage',
              '',
              '| | Module | Lines | Coverage |',
              '|---|--------|-------|----------|',
              ...rows,
              `| **${totalIcon}** | **Total** | **${totalCovered} / ${totalExecutable}** | **${totalPct.toFixed(1)}%** |`,
              '',
              `Minimum required: ${THRESHOLD}%`,
              '',
              `:package: [Download xcresult](${runUrl})`
            ].join('\n');

            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, body + '\n');

            core.setOutput('body', body);
            core.setOutput('total', totalPct.toFixed(1));
            core.setOutput('passed', totalPct >= THRESHOLD ? 'true' : 'false');

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${{ steps.coverage.outputs.body }}`
            });

      - name: Enforce coverage threshold
        if: steps.coverage.outputs.passed == 'false'
        run: |
          echo "::error::Code coverage (${{ steps.coverage.outputs.total }}%) is below the minimum threshold (${{ env.COVERAGE_THRESHOLD }}%)"
          exit 1
