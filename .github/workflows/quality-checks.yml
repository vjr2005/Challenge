name: Quality Checks

on:
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      module-strategy:
        description: "Module integration strategy (spm or framework)"
        required: false
        default: spm
        type: choice
        options:
          - spm
          - framework

env:
  MODULE_STRATEGY: ${{ github.event.inputs.module-strategy || 'spm' }}

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  unit-and-snapshot-tests:
    name: Unit & Snapshot Tests
    runs-on: macos-15
    timeout-minutes: 40

    env:
      TUIST_TEST_DEVICE: iPhone 17 Pro
      TUIST_TEST_OS: "26.1"
      DERIVED_DATA_PATH: derived_data
      RESULT_BUNDLE_PATH: test_output/UnitSnapshot.xcresult

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          device: ${{ env.TUIST_TEST_DEVICE }}
          derived-data-prefix: unit
          module-strategy: ${{ env.MODULE_STRATEGY }}

      - name: Generate project
        run: TUIST_MODULE_STRATEGY=${{ env.MODULE_STRATEGY }} mise x -- tuist generate --no-open

      - name: Run unit and snapshot tests
        timeout-minutes: 35
        run: |
          xcodebuild test \
            -workspace Challenge.xcworkspace \
            -scheme "Challenge (Dev)" \
            -testPlan Challenge \
            -destination "platform=iOS Simulator,name=$TUIST_TEST_DEVICE,OS=$TUIST_TEST_OS" \
            -derivedDataPath "$DERIVED_DATA_PATH" \
            -resultBundlePath "$RESULT_BUNDLE_PATH" \
            -retry-tests-on-failure

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: unit-snapshot-coverage
          path: test_output
          retention-days: 1

      - name: Test report
        if: always()
        uses: ./.github/actions/test-report
        with:
          title: Unit & Snapshot Test Results
          artifact-name: unit-snapshot-results
          result-bundle-path: ${{ env.RESULT_BUNDLE_PATH }}

      - name: Detect dead code
        id: periphery
        continue-on-error: true
        run: |
          set +e
          INDEX_STORE="${DERIVED_DATA_PATH}/Index.noindex/DataStore"
          if [ -d "$INDEX_STORE" ]; then
            echo "Reusing index store: $INDEX_STORE"
            OUTPUT=$(mise x -- periphery scan --skip-build --index-store-path "$INDEX_STORE" 2>&1)
          else
            echo "Index store not found, running full build"
            OUTPUT=$(mise x -- periphery scan 2>&1)
          fi
          echo "$OUTPUT"
          echo 'PERIPHERY_OUTPUT<<PERIPHERY_EOF' >> "$GITHUB_ENV"
          echo "$OUTPUT" >> "$GITHUB_ENV"
          echo 'PERIPHERY_EOF' >> "$GITHUB_ENV"

      - name: Periphery summary
        id: periphery-summary
        uses: actions/github-script@v7
        with:
          script: |
            const raw = process.env.PERIPHERY_OUTPUT || '';
            const output = raw.replace(/\x1b\[[0-9;]*m/g, '');

            const diagnosticRegex = /^(.+?):(\d+):(\d+):\s+warning:\s+(.+)$/gm;
            const findings = [];
            let match;
            while ((match = diagnosticRegex.exec(output)) !== null) {
              findings.push({
                file: match[1],
                line: match[2],
                description: match[4]
              });
            }

            let body;
            if (findings.length === 0) {
              body = [
                '## Periphery \u2014 Dead code detection',
                '',
                ':white_check_mark: No unused code detected.'
              ].join('\n');
            } else {
              const rows = findings.map(f => {
                const shortFile = f.file.replace(/^.*?(?=Features\/|Sources\/|Tests\/)/, '');
                return `| :warning: | \`${shortFile}\` | ${f.line} | ${f.description} |`;
              });

              body = [
                '## Periphery \u2014 Dead code detection',
                '',
                `Found **${findings.length}** unused code occurrence(s):`,
                '',
                '| | File | Line | Description |',
                '|---|------|------|-------------|',
                ...rows
              ].join('\n');
            }

            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, body + '\n');

            core.setOutput('body', body);

      - name: Comment PR with Periphery results
        if: github.event_name == 'pull_request'
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.periphery-summary.outputs.body }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: process.env.COMMENT_BODY
            });

  ui-tests:
    name: UI Tests
    runs-on: macos-15
    timeout-minutes: 40

    env:
      TUIST_TEST_DEVICE: iPhone 17 Pro
      TUIST_TEST_OS: "26.1"
      DERIVED_DATA_PATH: derived_data
      RESULT_BUNDLE_PATH: test_output/UITests.xcresult

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          device: ${{ env.TUIST_TEST_DEVICE }}
          derived-data-prefix: ui
          module-strategy: ${{ env.MODULE_STRATEGY }}

      - name: Run UI tests
        timeout-minutes: 35
        run: |
          mise x -- tuist test "ChallengeUITests" \
            --device "$TUIST_TEST_DEVICE" \
            --os "$TUIST_TEST_OS" \
            --result-bundle-path "$RESULT_BUNDLE_PATH" \
            -- -derivedDataPath "$DERIVED_DATA_PATH" \
            -retry-tests-on-failure \
            -test-repetition-relaunch-enabled YES

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-coverage
          path: test_output
          retention-days: 1

      - name: Test report
        if: always()
        uses: ./.github/actions/test-report
        with:
          title: UI Test Results
          artifact-name: ui-test-results
          result-bundle-path: ${{ env.RESULT_BUNDLE_PATH }}

  quality-gate:
    name: Quality Gate
    runs-on: macos-15
    needs: [unit-and-snapshot-tests, ui-tests]
    if: always()
    timeout-minutes: 10

    env:
      COVERAGE_THRESHOLD: 80

    steps:
      - name: Check job results
        run: |
          echo "Unit & Snapshot Tests: ${{ needs.unit-and-snapshot-tests.result }}"
          echo "UI Tests: ${{ needs.ui-tests.result }}"
          if [ "${{ needs.unit-and-snapshot-tests.result }}" != "success" ] || [ "${{ needs.ui-tests.result }}" != "success" ]; then
            echo "::error::One or more test jobs failed"
            exit 1
          fi

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-coverage'

      - name: Merge coverage data
        id: merge
        run: |
          mkdir -p merged-output
          if xcrun xcresulttool merge \
              unit-snapshot-coverage/UnitSnapshot.xcresult \
              ui-test-coverage/UITests.xcresult \
              --output-path merged-output/merged.xcresult 2>&1; then
            echo "merge_ok=true" >> "$GITHUB_OUTPUT"
            xcrun xccov view --report --json merged-output/merged.xcresult > coverage.json
          else
            echo "::warning::xcresulttool merge failed â€” falling back to independent coverage extraction"
            echo "merge_ok=false" >> "$GITHUB_OUTPUT"
            xcrun xccov view --report --json unit-snapshot-coverage/UnitSnapshot.xcresult > unit-coverage.json
            xcrun xccov view --report --json ui-test-coverage/UITests.xcresult > ui-coverage.json
          fi

      - name: Upload merged xcresult
        if: steps.merge.outputs.merge_ok == 'true'
        id: upload-merged
        uses: actions/upload-artifact@v4
        with:
          name: merged-xcresult
          path: merged-output
          retention-days: 7

      - name: Upload unit xcresult
        if: steps.merge.outputs.merge_ok != 'true'
        id: upload-unit
        uses: actions/upload-artifact@v4
        with:
          name: unit-snapshot-xcresult
          path: unit-snapshot-coverage
          retention-days: 7

      - name: Upload UI xcresult
        if: steps.merge.outputs.merge_ok != 'true'
        id: upload-ui
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-xcresult
          path: ui-test-coverage
          retention-days: 7

      - name: Coverage report
        id: coverage
        uses: actions/github-script@v7
        env:
          THRESHOLD: ${{ env.COVERAGE_THRESHOLD }}
          MERGE_OK: ${{ steps.merge.outputs.merge_ok }}
          MERGED_ARTIFACT_ID: ${{ steps.upload-merged.outputs.artifact-id }}
          UNIT_ARTIFACT_ID: ${{ steps.upload-unit.outputs.artifact-id }}
          UI_ARTIFACT_ID: ${{ steps.upload-ui.outputs.artifact-id }}
        with:
          script: |
            const fs = require('fs');
            const THRESHOLD = parseInt(process.env.THRESHOLD, 10);
            const mergeOk = process.env.MERGE_OK === 'true';

            // --- Load coverage targets ---
            let targets;
            if (mergeOk) {
              const report = JSON.parse(fs.readFileSync('coverage.json', 'utf8'));
              targets = report.targets;
            } else {
              // Merge coverage at file level from both reports
              const unitReport = JSON.parse(fs.readFileSync('unit-coverage.json', 'utf8'));
              const uiReport = JSON.parse(fs.readFileSync('ui-coverage.json', 'utf8'));

              const targetMap = new Map();
              for (const report of [unitReport, uiReport]) {
                for (const target of report.targets) {
                  if (!targetMap.has(target.name)) {
                    targetMap.set(target.name, new Map());
                  }
                  const fileMap = targetMap.get(target.name);
                  for (const file of (target.files || [])) {
                    const key = file.path || file.name;
                    const existing = fileMap.get(key);
                    if (!existing || file.coveredLines > existing.coveredLines) {
                      fileMap.set(key, {
                        coveredLines: file.coveredLines,
                        executableLines: file.executableLines,
                      });
                    }
                  }
                }
              }

              targets = [];
              for (const [name, fileMap] of targetMap) {
                let coveredLines = 0;
                let executableLines = 0;
                for (const f of fileMap.values()) {
                  coveredLines += f.coveredLines;
                  executableLines += f.executableLines;
                }
                const lineCoverage = executableLines > 0 ? coveredLines / executableLines : 0;
                targets.push({ name, coveredLines, executableLines, lineCoverage });
              }
            }

            // --- Filter targets ---
            const filtered = targets.filter(t => {
              const name = t.name.replace(/\.(framework|app|o)$/, '');
              return !name.includes('Mock') &&
                !name.includes('Test') &&
                !name.includes('SnapshotTestKit') &&
                name !== 'SnapshotTesting';
            });

            let totalCovered = 0;
            let totalExecutable = 0;

            const rows = filtered
              .sort((a, b) => a.name.localeCompare(b.name))
              .map(t => {
                totalCovered += t.coveredLines;
                totalExecutable += t.executableLines;
                const pct = (t.lineCoverage * 100).toFixed(1);
                const icon = parseFloat(pct) >= THRESHOLD ? ':white_check_mark:' : ':x:';
                const name = t.name.replace(/\.(framework|app|o)$/, '');
                return `| ${icon} | ${name} | ${t.coveredLines} / ${t.executableLines} | ${pct}% |`;
              });

            const totalPct = totalExecutable > 0
              ? (totalCovered / totalExecutable * 100)
              : 0;
            const totalIcon = totalPct >= THRESHOLD ? ':white_check_mark:' : ':x:';

            // --- Download links ---
            const baseUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}/artifacts`;
            let downloadSection;
            if (mergeOk) {
              const id = process.env.MERGED_ARTIFACT_ID;
              downloadSection = `:package: [Download xcresult](${baseUrl}/${id})`;
            } else {
              const unitId = process.env.UNIT_ARTIFACT_ID;
              const uiId = process.env.UI_ARTIFACT_ID;
              downloadSection = [
                `:package: [Unit+Snapshot xcresult](${baseUrl}/${unitId})`,
                `:package: [UI Tests xcresult](${baseUrl}/${uiId})`,
              ].join('\n');
            }

            const body = [
              '## Code Coverage',
              '',
              '| | Module | Lines | Coverage |',
              '|---|--------|-------|----------|',
              ...rows,
              `| **${totalIcon}** | **Total** | **${totalCovered} / ${totalExecutable}** | **${totalPct.toFixed(1)}%** |`,
              '',
              `Minimum required: ${THRESHOLD}%`,
              '',
              downloadSection,
            ].join('\n');

            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, body + '\n');

            core.setOutput('body', body);
            core.setOutput('total', totalPct.toFixed(1));
            core.setOutput('passed', totalPct >= THRESHOLD ? 'true' : 'false');

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.coverage.outputs.body }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: process.env.COMMENT_BODY
            });

      - name: Enforce coverage threshold
        if: steps.coverage.outputs.passed == 'false'
        run: |
          echo "::error::Code coverage (${{ steps.coverage.outputs.total }}%) is below the minimum threshold (${{ env.COVERAGE_THRESHOLD }}%)"
          exit 1
