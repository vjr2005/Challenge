name: Pull Request Checks

on:
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  build-and-test:
    name: Build & Test
    runs-on: macos-15
    timeout-minutes: 30

    env:
      TUIST_TEST_DEVICE: iPhone 17 Pro
      TUIST_TEST_OS: "26.1"
      RESULT_BUNDLE_PATH: test_output/Challenge.xcresult

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode 26.1.1
        run: |
          sudo xcode-select -s /Applications/Xcode_26.1.1.app
          xcodebuild -version

      - name: Install mise tools
        uses: jdx/mise-action@v2
        with:
          cache: true

      - name: Cache Tuist and SPM dependencies
        uses: actions/cache@v4
        with:
          path: |
            Tuist/.build
            Derived/
          key: tuist-${{ runner.os }}-${{ hashFiles('Tuist/Package.resolved') }}
          restore-keys: |
            tuist-${{ runner.os }}-

      - name: Install SPM dependencies
        run: mise x -- tuist install

      - name: Generate Xcode project
        run: mise x -- tuist generate

      - name: Prepare simulator
        run: |
          xcrun simctl shutdown all
          DEVICE_UDID=$(xcrun simctl list devices available -j | python3 -c "
          import json, sys
          data = json.load(sys.stdin)
          for runtime, devices in data['devices'].items():
              for d in devices:
                  if d['name'] == '${{ env.TUIST_TEST_DEVICE }}' and d['isAvailable']:
                      print(d['udid'])
                      sys.exit(0)
          ")
          if [ -n "$DEVICE_UDID" ]; then
            echo "Booting simulator: $DEVICE_UDID"
            xcrun simctl boot "$DEVICE_UDID"
            echo "Waiting for simulator to be ready..."
            sleep 5
          else
            echo "Warning: Target simulator not found, will rely on Tuist to create it"
          fi

      - name: Run tests
        timeout-minutes: 25
        run: |
          mise x -- tuist test \
            --device "$TUIST_TEST_DEVICE" \
            --os "$TUIST_TEST_OS" \
            --result-bundle-path "$RESULT_BUNDLE_PATH"

      - name: Upload xcresult on failure
        if: failure()
        id: upload-xcresult
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test_output
          retention-days: 7

      - name: Test results summary
        if: failure()
        id: test-summary
        run: |
          python3 << 'PYEOF'
          import json, subprocess, os

          result_bundle = os.environ['RESULT_BUNDLE_PATH']
          xcresult_url = os.environ.get('XCRESULT_URL', '')

          failures = []
          if os.path.isdir(result_bundle):
              result = subprocess.run(
                  ['xcrun', 'xcresulttool', 'get', 'test-results', 'tests',
                   '--path', result_bundle],
                  capture_output=True, text=True
              )
              if result.returncode == 0:
                  data = json.loads(result.stdout)

                  def walk(node, parts):
                      name = node.get('name', '')
                      node_type = node.get('nodeType', '')
                      if node_type == 'Test Plan':
                          for child in node.get('children', []):
                              walk(child, [])
                          return
                      current = parts + [name] if name else parts
                      if node.get('result') == 'Failed' and node_type == 'Test Case':
                          failures.append('/'.join(current))
                      for child in node.get('children', []):
                          walk(child, current)

                  for node in data.get('testNodes', []):
                      walk(node, [])

          lines = ['## Test Results', '', ':x: **Tests failed.**']
          if failures:
              lines += ['', '| | Test |', '|---|------|']
              lines += [f'| :x: | `{f}` |' for f in failures]
          if xcresult_url:
              lines += ['', f'[:arrow_down: Download xcresult]({xcresult_url})', '',
                        '_Open the `.xcresult` file in Xcode to inspect failures._']

          body = '\n'.join(lines)

          with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as summary:
              summary.write(body + '\n')

          with open(os.environ['GITHUB_OUTPUT'], 'a') as output:
              output.write('body<<TEST_BODY_EOF\n')
              output.write(body + '\n')
              output.write('TEST_BODY_EOF\n')
          PYEOF
        env:
          XCRESULT_URL: ${{ steps.upload-xcresult.outputs.artifact-url }}

      - name: Comment PR with test failures
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${{ steps.test-summary.outputs.body }}`
            });

      - name: Detect dead code
        id: periphery
        continue-on-error: true
        run: |
          set +e
          OUTPUT=$(mise x -- periphery scan 2>&1)
          echo "$OUTPUT"
          echo 'PERIPHERY_OUTPUT<<PERIPHERY_EOF' >> "$GITHUB_ENV"
          echo "$OUTPUT" >> "$GITHUB_ENV"
          echo 'PERIPHERY_EOF' >> "$GITHUB_ENV"

      - name: Periphery summary
        id: periphery-summary
        uses: actions/github-script@v7
        with:
          script: |
            const raw = process.env.PERIPHERY_OUTPUT || '';
            const output = raw.replace(/\x1b\[[0-9;]*m/g, '');

            const diagnosticRegex = /^(.+?):(\d+):(\d+):\s+warning:\s+(.+)$/gm;
            const findings = [];
            let match;
            while ((match = diagnosticRegex.exec(output)) !== null) {
              findings.push({
                file: match[1],
                line: match[2],
                description: match[4]
              });
            }

            let body;
            if (findings.length === 0) {
              body = [
                '## Periphery \u2014 Dead code detection',
                '',
                ':white_check_mark: No unused code detected.'
              ].join('\n');
            } else {
              const rows = findings.map(f => {
                const shortFile = f.file.replace(/^.*?(?=Features\/|Sources\/|Tests\/)/, '');
                return `| :warning: | \`${shortFile}\` | ${f.line} | ${f.description} |`;
              });

              body = [
                '## Periphery \u2014 Dead code detection',
                '',
                `Found **${findings.length}** unused code occurrence(s):`,
                '',
                '| | File | Line | Description |',
                '|---|------|------|-------------|',
                ...rows
              ].join('\n');
            }

            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, body + '\n');

            core.setOutput('body', body);

      - name: Comment PR with Periphery results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${{ steps.periphery-summary.outputs.body }}`
            });
